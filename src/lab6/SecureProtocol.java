package lab6;

import javax.crypto.Cipher;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.*;
import java.util.Base64;
import java.util.Scanner;

import static java.nio.charset.StandardCharsets.UTF_8;

public class SecureProtocol {

     public static String getCryptoHash(String input, String algorithm) {
            try {
                //MessageDigest classes Static getInstance method is called with MD5 hashing
                MessageDigest msgDigest = MessageDigest.getInstance(algorithm);

                //digest() method is called to calculate message digest of the input
                //digest() return array of byte.
                byte[] inputDigest = msgDigest.digest(input.getBytes());

                // Convert byte array into signum representation
                // BigInteger class is used, to convert the resultant byte array into its signum representation
                BigInteger inputDigestBigInt = new BigInteger(1, inputDigest);

                // Convert the input digest into hex value
                String hashtext = inputDigestBigInt.toString(16);

                //Add preceding 0's to pad the hashtext to make it 32 bit
                while (hashtext.length() < 32) {
                    hashtext = "0" + hashtext;
                }
                return hashtext;
            }
            // Catch block to handle the scenarios when an unsupported message digest algorithm is provided.
            catch (NoSuchAlgorithmException e) {
                throw new RuntimeException(e);
            }
        }


        public static KeyPair generateKeyPair() throws Exception {
            KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
            generator.initialize(2048, new SecureRandom());
            KeyPair pair = generator.generateKeyPair();

            return pair;
        }

        public static KeyPair getKeyPairFromKeyStore() throws Exception {
            //Generated with:
            //  keytool -genkeypair -alias mykey -storepass s3cr3t -keypass s3cr3t -keyalg RSA -keystore keystore.jks

            InputStream ins = SecureProtocol.class.getResourceAsStream("/keystore.jks");

            KeyStore keyStore = KeyStore.getInstance("JCEKS");
            keyStore.load(ins, "qwerty".toCharArray());   //Keystore password
            KeyStore.PasswordProtection keyPassword =       //Key password
                    new KeyStore.PasswordProtection("qwerty".toCharArray());

            KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry("key", keyPassword);

            java.security.cert.Certificate cert = keyStore.getCertificate("key");
            PublicKey publicKey = cert.getPublicKey();
            PrivateKey privateKey = privateKeyEntry.getPrivateKey();

            return new KeyPair(publicKey, privateKey);
        }

        public static String encrypt(String plainText, PublicKey publicKey) throws Exception {
            Cipher encryptCipher = Cipher.getInstance("RSA");
            encryptCipher.init(Cipher.ENCRYPT_MODE, publicKey);

            byte[] cipherText = encryptCipher.doFinal(plainText.getBytes(UTF_8));

            return Base64.getEncoder().encodeToString(cipherText);
        }

        public static String decrypt(String cipherText, PrivateKey privateKey) throws Exception {
            byte[] bytes = Base64.getDecoder().decode(cipherText);

            Cipher decriptCipher = Cipher.getInstance("RSA");
            decriptCipher.init(Cipher.DECRYPT_MODE, privateKey);

            return new String(decriptCipher.doFinal(bytes), UTF_8);
        }

        public static String sign(String plainText, PrivateKey privateKey) throws Exception {
            Signature privateSignature = Signature.getInstance("SHA256withRSA");
            privateSignature.initSign(privateKey);
            privateSignature.update(plainText.getBytes(UTF_8));

            byte[] signature = privateSignature.sign();

            return Base64.getEncoder().encodeToString(signature);
        }

        public static boolean verify(String plainText, String signature, PublicKey publicKey) throws Exception {
            Signature publicSignature = Signature.getInstance("SHA256withRSA");
            publicSignature.initVerify(publicKey);
            publicSignature.update(plainText.getBytes(UTF_8));

            byte[] signatureBytes = Base64.getDecoder().decode(signature);

            return publicSignature.verify(signatureBytes);
        }

        public static void main(String... argv) throws Exception,NoSuchAlgorithmException {
            //First generate a public/private key pair
            KeyPair pair = generateKeyPair();
            //KeyPair pair = getKeyPairFromKeyStore();



            //Our secret message
            Scanner sc = new Scanner(System.in);
            String msg = sc.next();
            System.out.println("HashCode Generated by MD5 is: " + getCryptoHash(msg, "MD5"));
            String message = getCryptoHash(msg, "MD5");
            //Encrypt the message
            String cipherText = encrypt(message, pair.getPublic());
            System.out.println("Encrypted message:" + cipherText);
            //Now decrypt it
            String decipheredMessage = decrypt(cipherText, pair.getPrivate());

            System.out.println("Decrypted message:" + decipheredMessage);

            //Let's sign our message
            String signature = sign("Aru", pair.getPrivate());

            //Let's check the signature
            boolean isCorrect = verify("Aru", signature, pair.getPublic());
            System.out.println("Signature correct: " + isCorrect);
        }
    }

